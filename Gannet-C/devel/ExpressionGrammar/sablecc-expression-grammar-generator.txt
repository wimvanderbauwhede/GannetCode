Generating an expression grammar for SableCC
Tags: SableCC, Gannet-C, java

Yes, you've read it correctly: this post is about generating a grammar _for_ SableCC, the Java-based parser generator. 

## Expression grammars in SableCC

An expression grammar is that part of a grammar that describes the syntax for operator-based expressions, e.g. 

	2*3-4>>5+6*7
	
The grammar for this expression must take into account the precedence, associativity and fixity of the operators. For example, the SableCC productions for a grammar for arithmetic expressions consisting of factors and terms (i.e. sums of products) look like this (omitting the transformation annotations):

	Productions

    grammar			= exp_list;

    exp_list		=
                        {list}    exp_list separator exp 
                      | {single}  exp           
                      ;

    exp				=  
                        {plus}    exp plus factor 
                      | {factor}  factor          
                      ;

    factor			=
                        {mult}    factor mult term 
                      | {term}    term             
                      ;

    term              {-> exp} =
                        {number}  number            
                      | {exp}     l_par exp r_par   
                      ;

    separator		= {semicolon} semi;

The AST is quite simple:

    Abstract Syntax Tree

    grammar           = exp+ ;

    exp               =
                        {plus}    [l]:exp  [r]:exp |
                        {mult}    [l]:exp  [r]:exp |
                        {number}  number
                      ;

This example illustrates an unfortunate aspect of SableCC: the complete expression grammar has to be written out as production rules for every level of precedence, with the correct associativity and fixity. Even the example for a simple two-operator grammar is already quite complicated. Also note that every operator (or to be precise every precedence level) requires a separate AST node. A real-life programming language such as C++ or Perl has typically about 30 different operators with more than 10 levels of precedence. Writing an expression grammar for such a set of operators is daunting to say the least.

## An expression grammar generator

However, the production rules for expression grammars are quite regular, so it is possible to generate the expression grammar using a script. That means we will be creating a parser generator grammar generator. 

Every level of precedence requires a separate production rule and as observed above, because of the limited way in which in SableCC the concrete syntax can be transformed into the abstract syntax, every one of these rules results in a different node in the AST. It is therefore essential that we can not only generate the grammar but also at least a skeleton for the visitor methods for every operator node in the AST. Each of the visitor methods should contain a switch/case statement to perform the correct action for each operator. Unfortunately, Java's switch/case does not allow matching of strings. Therefore we need to map the operators to a unique number.

## Perl to the rescue

For jobs like this, I very much prefer Perl over any other language; however, the design of the grammar generator is not Perl-specific (nor indeed SableCC-specific), so you can easily port it to your language of choice.

To generate the production rules (and the corresponding tokens, AST and visitor methods), we start from a table that succinctly describes our expression grammar: 

    my %optable=(
        1 => ['Prefix',['++', '--'],'AssocNone'],
        2 => ['Infix',['**'],'AssocRight'],
        3 => ['Prefix',['!','~'],'AssocRight'], 
        4 => ['Infix',['*','/','%'],'AssocLeft'], 
        5 => ['Infix',['+','-'],'AssocLeft'], 
        6 => ['Infix',['<<','>>'],'AssocLeft'],
        7 => ['Infix',['<=','>=','>','<'],'AssocNone'],
        8 => ['Infix',['==','!='],'AssocNone'], 
        9 => ['Infix',['&','bitand'],'AssocLeft'],
        10 => ['Infix',['|','^','bitor','xor'],'AssocLeft'],
        11 => ['Infix',['&&','and'],'AssocLeft'],
        12 => ['Infix',['||','or'],'AssocLeft'],
        13 => ['Infix',['='],'AssocRight'],
    );

Looks familiar? 

